# 镜像推送流程

```shell
allrun image push 本地镜像名
# 示例 1：使用本地镜像记录的原始引用名作为推送目标
allrun image push alpine-3_18_0

# 示例 2：显式指定推送目标引用名
allrun image push alpine-3_18_0 \
  --target registry.cn-shanghai.aliyuncs.com/tangxusc/alpine:3.18.0
```

## CLI 用法

- **基础命令**：`allrun image push IMAGE`
  - **IMAGE**：
    - 可以是 `allrun image list` 输出中的第一列（本地镜像存储目录名，例如 `alpine-3_18_0`）。
    - 也可以是原始镜像引用名（`ListImages` 第二列，例如 `registry.cn-shanghai.aliyuncs.com/tangxusc/alpine:3.18.0`）。
  - 默认从全局 `--images-store-dir` 指定的目录中查找要推送的镜像。

- **可选参数**：
  - **--target**：
    - 指定推送到远程仓库时使用的目标镜像引用名。
    - 若未指定，则优先使用本地镜像记录的原始引用名（`org.opencontainers.image.ref.name` 注解）；如果本地镜像未记录原始引用名，则命令会报错提示需要显式指定 `--target`。
  - **--tls-verify**：
    - 是否验证 TLS 证书，默认为 `true`。
    - 当设置为 `false` 时，将允许跳过证书校验并支持 http 访问，仅推荐在受信任的私有环境中使用。

- **认证说明**：
  - 推送时会根据目标镜像引用中的 registry（如 `registry.cn-shanghai.aliyuncs.com`）读取 `allrun image login` 写入的认证信息。
  - 认证文件路径：`/var/lib/ar/auth.json`。
  - 若存在匹配的 registry 登录信息，则使用 basic auth 推送镜像；否则以匿名方式尝试推送，是否允许匿名由目标 registry 决定。

## 内部流程说明

以 `allrun image push alpine-3_18_0 --target registry.cn-shanghai.aliyuncs.com/tangxusc/alpine:3.18.0` 为例，内部流程如下：

1. **解析参数**
   - 从 CLI 解析出：
     - `IMAGE`：`alpine-3_18_0`
     - `--target`：`registry.cn-shanghai.aliyuncs.com/tangxusc/alpine:3.18.0`
     - `--tls-verify`（默认 `true`）
   - 传入 `PushImageFromStore(imageNameOrRef, storeDir, targetRef, tlsVerify)`。

2. **匹配本地镜像**
   - 调用 `ListImages(--images-store-dir)`，枚举本地镜像存储目录下的所有 OCI layout：
     - 每条记录包含：
       - `Name`：存储目录名（`alpine-3_18_0`）
       - `Ref`：从 OCI layout 的 `org.opencontainers.image.ref.name` 注解中读取的原始镜像引用名。
   - 在列表中匹配符合条件的镜像：
     - `e.Name == IMAGE`
     - 或 `e.Ref == IMAGE`
     - 或 `sanitize(IMAGE)` 后与 `e.Name` 相等。
   - 若未匹配到，则返回错误：“在本地镜像存储目录中未找到指定镜像”。

3. **确定推送目标引用名**
   - 若 CLI 传入了 `--target`，则以该参数为最终推送目标引用名。
   - 否则：
     - 使用本地镜像记录的原始引用名 `Ref` 作为推送目标。
     - 如果 `Ref` 为空（例如镜像导入时没有设置 ref 注解），则返回错误，提示用户通过 `--target` 显式指定目标镜像名。

4. **构造 registry 引用与 TLS 设置**
   - 使用 `go-containerregistry` 的 `name.ParseReference` 解析目标镜像引用，得到：
     - registry 地址（例如 `registry.cn-shanghai.aliyuncs.com`）。
     - 仓库名与 tag。
   - 若 `--tls-verify=false`：
     - 在解析镜像引用时使用 `name.Insecure` 选项，允许 http 及不安全 TLS。
     - 在后续远程操作中配置自定义 `http.Transport`，设置 `InsecureSkipVerify=true`。

5. **附加认证信息**
   - 从 `/var/lib/ar/auth.json` 中读取 `image login` 保存的 registry 登录信息：
     - 数据结构为按 registry 维度存储 `username/password`。
   - 取目标镜像引用中的 registry 作为 key（`ref.Context().RegistryStr()`），查找对应的认证条目。
   - 若找到匹配项，则在远程推送选项中附加 basic auth（`remote.WithAuth`）；否则不附加认证，以匿名身份推送。

6. **从本地 store 打开镜像**
   - 调用 `OpenImageFromStore(--images-store-dir, matched.Name)`：
     - 根据镜像存储目录名在本地 `--images-store-dir` 中找到对应的 OCI layout 目录。
     - 使用 `layout.FromPath` 打开 OCI index，定位到镜像 manifest 并得到 `v1.Image` 对象。

7. **推送到远程镜像仓库**
   - 使用 `remote.Write(ref, img, remoteOptions...)` 将本地 `v1.Image` 推送到远程 registry：
     - 使用上一步得到的目标镜像引用 `ref`。
     - 使用包含 TLS 与认证设置的 `remoteOptions`。
   - 推送成功后返回最终镜像引用名，用于在 CLI 层打印日志：
     - 例如：`镜像已推送到远程仓库: registry.cn-shanghai.aliyuncs.com/tangxusc/alpine:3.18.0`。

## 与镜像拉取流程的关系

- **共同点**：
  - 都使用 `--images-store-dir` 作为本地 OCI layout 镜像存储目录。
  - 都通过 `/var/lib/ar/auth.json` 中的 registry 登录信息进行认证（`allrun image login` 统一入口）。
  - 都支持通过 `--tls-verify` 控制是否跳过 TLS 证书校验。

- **差异点**：
  - **拉取（pull）**：
    - 数据流向：远程 registry → 本地镜像存储目录。
    - 使用 `remote.Image` 从远程拉取镜像并写入本地。
  - **推送（push）**：
    - 数据流向：本地镜像存储目录 → 远程 registry。
    - 使用 `OpenImageFromStore` 从本地读取镜像，再通过 `remote.Write` 推送到远程。

