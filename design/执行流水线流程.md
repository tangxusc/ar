# 执行流水线流程

## 执行流水线
```graphql
type RunPipelineInput {
  pipelineName: String! # 流水线名称
  nodes: [Node!]! # 节点列表
}

type Label {
  key: String! # 标签键
  value: String! # 标签值
}

type Node {
  ip: String! # 节点IP
  port: String # 节点端口
  username: String! # 节点用户名
  password: String! # 节点密码
  labels: [Label!]! # 标签列表
}

type PipelineRunTask {
    taskId: String! # 任务ID(容器id)
    data: String! # 数据(有向无环图dag图)
}

mutation RunPipeline($input: RunPipelineInput!) {
  runPipeline(input: $input) {
    ...PipelineRunTask
  }
}

# 停止执行流水线
```graphql
mutation StopPipeline($taskId: String!) {
  stopPipeline(taskId: $taskId) {
    ...PipelineRunTask
  }
}
```

# 订阅任务执行情况
subscription SubscribeTaskExecution($taskId: String!) {
  subscribeTaskExecution(taskId: $taskId) {
    taskId: String! # 任务ID(容器id)
    data: String! # 数据(有向无环图dag图)
  }
}

# 订阅任务日志
subscription SubscribeTaskLog($taskId: String!, $nodeId: String!) {
  subscribeTaskLog(taskId: $taskId, nodeId: $nodeId) {
    log: String! # 日志
  }
}
```

执行流水线时,调用graphql接口,传入流水线执行参数(RunPipelineInput),接口返回执行结果(PipelineRunTask),返回结果释义:
taskId: 任务ID(容器id)
data: 数据(有向无环图dag图),dag图的每个节点代表一个任务,节点之间的有向边代表任务之间的依赖关系。
在执行流水线时,读取pipeline_name.template.json文件,根据文件内容和节点列表, 使用golang template包生成执行计划dag图,并生成一个唯一的taskID(时间戳_随机数)。
在宿主机`/var/lib/ar/pipeline_name/时间戳_随机数/`目录下,写入`pipeline.json`,内容为执行计划dag;
调用podman run api 逐步运行dag中定义的容器(容器名称 ar_pipename_时间);
每个容器运行时,将宿主机`/var/lib/ar/pipeline_name/时间戳_随机数/` 目录挂载到容器`/tasks/`目录下;
将宿主机`/var/lib/ar/pipeline_name/时间戳_随机数/nodex` 目录挂载到容器`/current-task/`目录下;
逐步运行容器的过程中,不断更新`/var/lib/ar/pipeline_name/时间戳_随机数/pipeline.json`文件,记录每个容器运行情况。
在容器退出码为0时,不再继续运行下一个容器,并返回执行结果。

文件结构实例:
```shell
/var/lib/ar/pipeline_name/时间戳_随机数/ # 流水线执行目录
/var/lib/ar/pipeline_name/时间戳_随机数/node1 # 节点1执行目录
/var/lib/ar/pipeline_name/时间戳_随机数/node2 # 节点2执行目录
/var/lib/ar/pipeline_name/时间戳_随机数/node3 # 节点3执行目录

```
