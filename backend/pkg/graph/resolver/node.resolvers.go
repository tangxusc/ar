package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/tangxusc/ar/backend/pkg/graph"
	"github.com/tangxusc/ar/backend/pkg/graph/model"
)

// AddNode is the resolver for the addNode field.
func (r *mutationResolver) AddNode(ctx context.Context, input model.AddNodeInput) (*model.NodeList, error) {
	labels := make([]*model.Label, 0, len(input.Labels))
	for _, l := range input.Labels {
		if l == nil {
			continue
		}
		labels = append(labels, &model.Label{
			Key:   l.Key,
			Value: l.Value,
		})
	}

	node := &model.Node{
		IP:       input.IP,
		Port:     input.Port,
		Username: input.Username,
		Password: input.Password,
		Labels:   labels,
	}

	if err := saveNode(node); err != nil {
		return nil, err
	}

	return loadAllNodes()
}

// UpdateNode is the resolver for the updateNode field.
func (r *mutationResolver) UpdateNode(ctx context.Context, input model.UpdateNodeInput) (*model.NodeList, error) {
	path := nodeFilePath(input.IP)
	if _, err := os.Stat(path); err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("node %s not found", input.IP)
		}
		return nil, err
	}

	labels := make([]*model.Label, 0, len(input.Labels))
	for _, l := range input.Labels {
		if l == nil {
			continue
		}
		labels = append(labels, &model.Label{
			Key:   l.Key,
			Value: l.Value,
		})
	}

	node := &model.Node{
		IP:       input.IP,
		Port:     input.Port,
		Username: input.Username,
		Password: input.Password,
		Labels:   labels,
	}

	if err := saveNode(node); err != nil {
		return nil, err
	}

	return loadAllNodes()
}

// DeleteNode is the resolver for the deleteNode field.
func (r *mutationResolver) DeleteNode(ctx context.Context, input model.DeleteNodeInput) (*model.NodeList, error) {
	path := nodeFilePath(input.IP)
	if err := os.Remove(path); err != nil && !os.IsNotExist(err) {
		return nil, err
	}
	return loadAllNodes()
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context) ([]*model.Node, error) {
	nodes, err := loadAllNodes()
	if err != nil {
		return nil, err
	}
	return nodes.Nodes, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, ip string) (*model.Node, error) {
	path := nodeFilePath(ip)
	if _, err := os.Stat(path); err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("node %s not found", ip)
		}
		return nil, err
	}
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var n model.Node
	if err := json.Unmarshal(data, &n); err != nil {
		return nil, err
	}
	return &n, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
const (
	nodesDir = "/var/lib/ar/nodes"
)

func nodeFilePath(ip string) string {
	return filepath.Join(nodesDir, fmt.Sprintf("node_%s.json", ip))
}
func loadAllNodes() (*model.NodeList, error) {
	if _, err := os.Stat(nodesDir); os.IsNotExist(err) {
		// 目录不存在时返回空列表
		return &model.NodeList{Nodes: []*model.Node{}}, nil
	}

	entries, err := os.ReadDir(nodesDir)
	if err != nil {
		return nil, err
	}

	nodes := make([]*model.Node, 0, len(entries))
	for _, e := range entries {
		if e.IsDir() {
			continue
		}
		name := e.Name()
		if !strings.HasPrefix(name, "node_") || !strings.HasSuffix(name, ".json") {
			continue
		}
		data, err := os.ReadFile(filepath.Join(nodesDir, name))
		if err != nil {
			return nil, err
		}
		var n model.Node
		if err := json.Unmarshal(data, &n); err != nil {
			return nil, err
		}
		// 需要指针类型
		nCopy := n
		nodes = append(nodes, &nCopy)
	}
	return &model.NodeList{Nodes: nodes}, nil
}
func saveNode(n *model.Node) error {
	if err := os.MkdirAll(nodesDir, 0o755); err != nil {
		return err
	}
	data, err := json.MarshalIndent(n, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(nodeFilePath(n.IP), data, 0o600)
}
